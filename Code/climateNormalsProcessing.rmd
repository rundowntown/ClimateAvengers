---
title: "Climate_Normals"
author: "DCF"
date: "2024-03-13"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(tidyverse)
library(purrr)
library(ggplot2)
library(ggmap)
library(zipcodeR)
```

## Climate Normals  

* Desc: https://www.ncei.noaa.gov/metadata/geoportal/rest/metadata/item/gov.noaa.ncdc:C01621/html#
* Lit: https://journals.ametsoc.org/configurable/content/journals$002fbams$002f93$002f11$002fbams-d-11-00197.1.xml?t:ac=journals%24002fbams%24002f93%24002f11%24002fbams-d-11-00197.1.xml
* Source: https://www.ncei.noaa.gov/access/search/data-search/normals-daily-1991-2020?bbox=44.832,-98.635,37.831,-86.440&pageNum=1&dataTypes=DLY-TAVG-NORMAL&dataTypes=DLY-TMAX-NORMAL&dataTypes=DLY-TMIN-NORMAL&dataTypes=MTD-PRCP-NORMAL&dataTypes=MTD-SNOW-NORMAL



## Data Load
Loads the Data.  Set the State of Interest at the top of the script.  This must match the Case that the `Raw.csv` file contains for the `State` in question.  

This script will:
- Load the Raw Climate 30 Year Normals
- Rename Columns of Interest
- Select Columns of Interest
- Handle `-9999` Missing Values (More Cleaning Needed)
- Identify All Unique Weather Stations (Locations)
- Generate Zip Codes based on Location with GOOGLE MAPS API for all Unique Locations
- Generate County Names, Radius, State Abrv. and Lat/Long County Bounds from Zip
- Left Join Zip And County Information onto Normals Data
- Write .csv of `Ready to Work` Normals and Stations/Counties .CSV

```{r dataLoad}
####
## Read in Climate Normals
####

## ************ SET STATE ************
## IMPORTANT: Set State of Interest Here
myState <- "Iowa"
##
## ************************************


# Dynamically construct the file path
normalsFilePath <- paste0('./Climate_Normals/', myState, 'NormalsRaw.csv')
myNormals <- read.csv(normalsFilePath)

## Rename Columns of Interest
myNormals <- myNormals %>%
  rename(
    normalAvgTemp = `DLY.TAVG.NORMAL`,        ## Temp Normal
    normalAvgTempStd = `DLY.TAVG.STDDEV`,     ## Normal Std
    normalMaxTemp = `DLY.TMAX.NORMAL`,        ## Max Normal
    normalMaxTempStd = `DLY.TMAX.STDDEV`,     ## Max Std
    normalMinTemp = `DLY.TMIN.NORMAL`,        ## Min Normal
    normalMinTempStd = `DLY.TMIN.STDDEV`,     ## Min Std
    normalMtdPrcp = `MTD.PRCP.NORMAL`,        ## Month to Date Precipitation Norm
    normalMtdSnow = `MTD.SNOW.NORMAL`,        ## Month to Date Snow Norm
    Lat = 'LATITUDE',
    Long = 'LONGITUDE',
  )


## Select Columns of Interest
normalSelect <- myNormals %>% 
  dplyr::select(DATE, normalAvgTemp, normalAvgTempStd,
                normalMaxTemp, normalMaxTempStd, normalMinTemp,
                normalMinTempStd, normalMtdPrcp, normalMtdSnow,
                ELEVATION, STATION, Long, Lat, )


## Replace -9999 with NA across the entire dataset
## [-9999 is Missing Value Code in this Dataset]
normalSelect <- normalSelect %>%
  mutate(across(where(is.numeric), ~na_if(.x, -9999)))

```


## Zip Code Generation
Generates Zip Code with GOOGLE MAPS API, gets County and Bounds information from Zip Code info.
```{r zipCode Generation}
######
## Zip Code Generation
######

## Access an environment variable in R 
## (API KEY Is Hidden Locally)
api_key <- Sys.getenv("GOOGLE_MAP_API_MGT")

## Register Google API Key with ggmap
register_google(key = api_key)


########################
## Get Zip Code Function
##
## Retrieve Postal Code for Given Latitude and Longitude
##
## This function performs reverse geocoding using the Google Maps Geocoding API
## to find the postal code (zip code) corresponding to a set of geographical coordinates.
## It requires the `ggmap` package and a valid Google API key registered via `ggmap::register_google()`
#########################
get_zip_code <- function(lat, long) {
  coords <- c(long, lat) # ggmap expects longitude first
  address_info <- tryCatch({
    revgeocode(coords, output = "all")
  }, error = function(e) return(NULL))
  
  if (is.null(address_info) || length(address_info$results) == 0) {
    return(NA)
  }
  
  postal_code <- NA
  for (component in address_info$results[[1]]$address_components) {
    if ("postal_code" %in% component$types) {
      postal_code <- component$long_name
      break
    }
  }
  
  return(postal_code)
}
######### End Function #########


## Extract unique STATIONS from `Climate Normals`
uniqueStations <- normalSelect %>%
  select(STATION, Lat, Long) %>%
  distinct()

## Reverse Geocode ZIPCODES for Unique Stations [[API CALL]]
uniqueStations <- uniqueStations %>%
  mutate(ZipCode = map2_chr(Lat, Long, ~get_zip_code(.x, .y)))


## Get All Zipcode Information from [zipcodeR]
## BoundsDirection are County Bounds
uniqueStations <- uniqueStations %>%
  mutate(ZipCode = as.character(ZipCode),                        ## Ensure ZipCode is a character
         ZipCode = ifelse(nchar(ZipCode) == 5, ZipCode, NA)) %>% ## Set invalid zip codes to NA
  mutate(CountyInfo = map(ZipCode, ~tryCatch({
    reverse_zipcode(.x)
  }, error = function(e) {
    ## Return NA Datafame if Error
    return(data.frame(county=NA, state=NA, radius_in_miles=NA,
                      bounds_west=NA, bounds_east=NA, bounds_north=NA, bounds_south=NA))
  }))) %>%
  mutate(
    ## Zipcode Information Columns Collecting
    County = map_chr(CountyInfo, ~.x$county),
    State = map_chr(CountyInfo, ~.x$state),
    RadiusInMiles = map_dbl(CountyInfo, ~.x$radius_in_miles),
    BoundsWest = map_dbl(CountyInfo, ~.x$bounds_west),
    BoundsEast = map_dbl(CountyInfo, ~.x$bounds_east),
    BoundsNorth = map_dbl(CountyInfo, ~.x$bounds_north),
    BoundsSouth = map_dbl(CountyInfo, ~.x$bounds_south)
  ) %>%
  select(-CountyInfo)          ## Removing the temporary CountyInfo column



## Merge back to the original dataset to assign ZipCode based on STATION
normalSelect <- normalSelect %>%
  left_join(uniqueStations, by = c("STATION", "Lat", "Long"))



```  




Writes the .CSV for 30 Year State Normals and State Stations.  Saved in the `/Climate_Normals` Folder.
```{r csvWrite}
## Writes CSV

## Produces .CSV with State Name Specificed at Top of Script
## Files are located in /Climate_Normals folder


## Construct the file paths for output
normalsOutputPath <- paste0('./Climate_Normals/', myState, 'NormalsReady.csv')
stationsOutputPath <- paste0('./Climate_Normals/', myState, 'StationsReady.csv')

## Write Normals: {State}NormalsReady.csv
write.csv(normalSelect, normalsOutputPath, row.names = FALSE)

## Write Stations: {State}StationsReady.csv
write.csv(uniqueStations, stationsOutputPath, row.names = FALSE)

```









